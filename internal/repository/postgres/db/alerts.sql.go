// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: alerts.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAlerts = `-- name: CountAlerts :one
SELECT COUNT(*) FROM alerts
WHERE 
    ($1::text = '' OR type = $1) AND
    ($2::text = '' OR severity = $2) AND
    ($3::text = '' OR source = $3) AND
    ($4::boolean IS NULL OR is_active = $4)
`

type CountAlertsParams struct {
	Column1 string `db:"column_1" json:"column_1"`
	Column2 string `db:"column_2" json:"column_2"`
	Column3 string `db:"column_3" json:"column_3"`
	Column4 bool   `db:"column_4" json:"column_4"`
}

func (q *Queries) CountAlerts(ctx context.Context, arg CountAlertsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAlerts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAlert = `-- name: CreateAlert :one
INSERT INTO alerts (
    id, type, severity, title, message, source, metadata, created_at, updated_at, is_active, is_resolved
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, type, severity, title, message, source, metadata, created_at, updated_at, resolved_at, is_active, is_resolved
`

type CreateAlertParams struct {
	ID         uuid.UUID        `db:"id" json:"id"`
	Type       string           `db:"type" json:"type"`
	Severity   string           `db:"severity" json:"severity"`
	Title      string           `db:"title" json:"title"`
	Message    string           `db:"message" json:"message"`
	Source     string           `db:"source" json:"source"`
	Metadata   json.RawMessage  `db:"metadata" json:"metadata"`
	CreatedAt  pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt  pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	IsActive   pgtype.Bool      `db:"is_active" json:"is_active"`
	IsResolved pgtype.Bool      `db:"is_resolved" json:"is_resolved"`
}

func (q *Queries) CreateAlert(ctx context.Context, arg CreateAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, createAlert,
		arg.ID,
		arg.Type,
		arg.Severity,
		arg.Title,
		arg.Message,
		arg.Source,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.IsActive,
		arg.IsResolved,
	)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Source,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResolvedAt,
		&i.IsActive,
		&i.IsResolved,
	)
	return i, err
}

const deleteAlert = `-- name: DeleteAlert :exec
DELETE FROM alerts WHERE id = $1
`

func (q *Queries) DeleteAlert(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAlert, id)
	return err
}

const getActiveAlerts = `-- name: GetActiveAlerts :many
SELECT id, type, severity, title, message, source, metadata, created_at, updated_at, resolved_at, is_active, is_resolved FROM alerts
WHERE is_active = true AND is_resolved = false
ORDER BY severity DESC, created_at DESC
`

func (q *Queries) GetActiveAlerts(ctx context.Context) ([]Alert, error) {
	rows, err := q.db.Query(ctx, getActiveAlerts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Source,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
			&i.IsActive,
			&i.IsResolved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlertByID = `-- name: GetAlertByID :one
SELECT id, type, severity, title, message, source, metadata, created_at, updated_at, resolved_at, is_active, is_resolved FROM alerts WHERE id = $1
`

func (q *Queries) GetAlertByID(ctx context.Context, id uuid.UUID) (Alert, error) {
	row := q.db.QueryRow(ctx, getAlertByID, id)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Source,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResolvedAt,
		&i.IsActive,
		&i.IsResolved,
	)
	return i, err
}

const getAlerts = `-- name: GetAlerts :many
SELECT id, type, severity, title, message, source, metadata, created_at, updated_at, resolved_at, is_active, is_resolved FROM alerts
WHERE 
    ($1::text = '' OR type = $1) AND
    ($2::text = '' OR severity = $2) AND
    ($3::text = '' OR source = $3) AND
    ($4::boolean IS NULL OR is_active = $4)
ORDER BY 
    CASE WHEN $5 = 'created_at' THEN created_at END,
    CASE WHEN $5 = 'updated_at' THEN updated_at END,
    CASE WHEN $5 = 'severity' THEN severity END,
    CASE WHEN $5 = 'type' THEN type END
LIMIT $6 OFFSET $7
`

type GetAlertsParams struct {
	Column1 string      `db:"column_1" json:"column_1"`
	Column2 string      `db:"column_2" json:"column_2"`
	Column3 string      `db:"column_3" json:"column_3"`
	Column4 bool        `db:"column_4" json:"column_4"`
	Column5 interface{} `db:"column_5" json:"column_5"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

func (q *Queries) GetAlerts(ctx context.Context, arg GetAlertsParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, getAlerts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Source,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
			&i.IsActive,
			&i.IsResolved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlertsBySeverity = `-- name: GetAlertsBySeverity :many
SELECT id, type, severity, title, message, source, metadata, created_at, updated_at, resolved_at, is_active, is_resolved FROM alerts
WHERE severity = $1
ORDER BY created_at DESC
`

func (q *Queries) GetAlertsBySeverity(ctx context.Context, severity string) ([]Alert, error) {
	rows, err := q.db.Query(ctx, getAlertsBySeverity, severity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Source,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
			&i.IsActive,
			&i.IsResolved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAlertResolved = `-- name: MarkAlertResolved :exec
UPDATE alerts 
SET is_resolved = true, is_active = false, resolved_at = $2, updated_at = $2
WHERE id = $1
`

type MarkAlertResolvedParams struct {
	ID         uuid.UUID        `db:"id" json:"id"`
	ResolvedAt pgtype.Timestamp `db:"resolved_at" json:"resolved_at"`
}

func (q *Queries) MarkAlertResolved(ctx context.Context, arg MarkAlertResolvedParams) error {
	_, err := q.db.Exec(ctx, markAlertResolved, arg.ID, arg.ResolvedAt)
	return err
}

const updateAlert = `-- name: UpdateAlert :exec
UPDATE alerts 
SET type = $2, severity = $3, title = $4, message = $5, source = $6, 
    metadata = $7, updated_at = $8, resolved_at = $9, is_active = $10, is_resolved = $11
WHERE id = $1
`

type UpdateAlertParams struct {
	ID         uuid.UUID        `db:"id" json:"id"`
	Type       string           `db:"type" json:"type"`
	Severity   string           `db:"severity" json:"severity"`
	Title      string           `db:"title" json:"title"`
	Message    string           `db:"message" json:"message"`
	Source     string           `db:"source" json:"source"`
	Metadata   json.RawMessage  `db:"metadata" json:"metadata"`
	UpdatedAt  pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	ResolvedAt pgtype.Timestamp `db:"resolved_at" json:"resolved_at"`
	IsActive   pgtype.Bool      `db:"is_active" json:"is_active"`
	IsResolved pgtype.Bool      `db:"is_resolved" json:"is_resolved"`
}

func (q *Queries) UpdateAlert(ctx context.Context, arg UpdateAlertParams) error {
	_, err := q.db.Exec(ctx, updateAlert,
		arg.ID,
		arg.Type,
		arg.Severity,
		arg.Title,
		arg.Message,
		arg.Source,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ResolvedAt,
		arg.IsActive,
		arg.IsResolved,
	)
	return err
}
